<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-gb">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>FPGA Memory Types | Project F - FPGA Development</title>

<meta property='og:title' content='FPGA Memory Types - Project F - FPGA Development'>
<meta property='og:description' content='Designing with FPGAs involves many types of memory, some familiar from other devices, but some that are specific to FPGAs. This post gives a quick overview of the different flavours, together with their strengths and weaknesses. This guide includes external memory types, such as SRAM and HBM, that are used in CPUs and GPUs, so much of what is said here is generally applicable, but the focus is on FPGAs.'>
<meta property='og:url' content='https://projectf.io/posts/fpga-memory-types/'>
<meta property='og:site_name' content='Project F - FPGA Development'>
<meta property='og:type' content='article'><meta property='og:image' content='https://projectf.io/img/posts/initialize-memory-in-verilog/social-card.jpg'><meta property='article:published_time' content='2020-08-24T00:00:00Z'/><meta property='article:modified_time' content='2020-08-24T00:00:00Z'/><meta name='twitter:card' content='summary_large_image'><meta name='twitter:site' content='@WillFlux'><meta name='twitter:creator' content='@WillFlux'>


<link href="https://projectf.io/index.xml" rel="alternate" type="application/rss+xml" title="Project F - FPGA Development" />

<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://projectf.io/posts/fpga-memory-types/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
<meta name="referrer" content="no-referrer, same-origin">
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://projectf.io">
          <h1 id="nav-heading" class="title is-4">Project F - FPGA Development</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/projf'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/WillFlux'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="youtube" href='https://youtube.com/channel/UCaT0lvfWo1GStbp0neg8weg'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"/>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="rss" href='/index.xml'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/sitemap">
          <h2 class="title is-5">Sitemap</h2>
        </a><a class="nav-item" href="/tags/cookbook">
          <h2 class="title is-5">Cookbook</h2>
        </a><a class="nav-item" href="/tags/explore">
          <h2 class="title is-5">Explore</h2>
        </a><a class="nav-item" href="/tags/tools">
          <h2 class="title is-5">Tools</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/cookbook/">#cookbook</a>



  
  | <a class="subtitle is-6" href="/tags/memory/">#memory</a>
  


      
    </div>
    <h2 class="subtitle is-6">24 August 2020</h2>
    <h1 class="title">FPGA Memory Types</h1>
    
    <div class="content">
      <p>Designing with FPGAs involves many types of memory, some familiar from other devices, but some that are specific to FPGAs. This post gives a quick overview of the different flavours, together with their strengths and weaknesses. This guide includes external memory types, such as SRAM and HBM, that are used in CPUs and GPUs, so much of what is said here is generally applicable, but the focus is on FPGAs.</p>
<p>To give you a sense of the memory capability of small FPGAs, we include the memory specifications for Lattice iCE40 UP5K and Xilinx Spartan 7S25.</p>
<p><strong>NB. This post is unfinished: expect additional content, fixes, and improvements over the coming days.</strong></p>
<p><em>Updated 2020-08-25. Feedback to <a href="https://twitter.com/WillFlux">@WillFlux</a> is most welcome.</em></p>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#memory-terminology">Memory Terminology</a></li>
<li><a href="#flip-flops">Flip-Flops</a></li>
<li><a href="#distributed-ram">Distributed RAM</a></li>
<li><a href="#block-ram">Block RAM</a></li>
<li><a href="#static-ram">Static RAM</a></li>
<li><a href="#dynamic-ram">Dynamic RAM</a></li>
<li><a href="#serial-ram">Serial RAM</a></li>
<li><a href="#high-bandwidth-memory">High Bandwidth Memory</a></li>
</ul>
<h2 id="memory-terminology">Memory Terminology</h2>
<ul>
<li><strong>Address Width</strong> - how many bits are needed to address all the elements in the memory array</li>
<li><strong>Bandwidth</strong> - how much data can be transferred by a memory interface each second</li>
<li><strong>(Data) Width</strong> - how many bits there are in each element</li>
<li><strong>Depth</strong> - how many elements there are in the memory array</li>
<li><strong>Latency</strong> - how long it takes for a memory interface to start returning data</li>
</ul>
<p><em>ProTip: In SystemVerilog you can use $clog2 to calculate the address width from the depth.</em></p>
<h2 id="flip-flops">Flip-Flops</h2>
<p>Flip-flops are the state keepers of an FPGA. They remember just one bit, but do so quickly and right where you need them: close to the LUTs that create your logic. When you create a simple counter you&rsquo;re using flip-flops:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog">    <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">15</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 16 flip-flops
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
        cnt <span style="color:#f92672">&lt;=</span> cnt <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">end</span>
</code></pre></div><p>Flip-flops are great for saving state, but they&rsquo;re not ideal for all but the smallest memories: their numbers are limited, they are spread throughout the FPGA (making routing larger memories hard), and they don&rsquo;t support multiple ports.</p>
<p>The Lattice iCE40 UP5K has 5,280 flip-flops, while the Xilinx Spartan 7S25 has 29,200.</p>
<h2 id="distributed-ram">Distributed RAM</h2>
<p>Distributed ram is built with LUTs. LUTs are usually used to create the logic of your design, but can also support memory in some FPGAs. Distributed ram is, as its name suggests, distributed throughout the FPGA in the same way as flip-flops. A single 6-input LUT can store 64 bits.</p>
<p>Distributed ram is read asynchronously, but written to synchronously (requires a clock). Writes are limited to a single port, but you can read from up to four ports in some FPGAs. Distributed ram is flexible in the data width it supports, for example, if dealing with 32-level data you can make the data width 5 bits.</p>
<p>Given the asynchronous nature of reads, distributed ram is ideal for fast buffers: you can use a value immediately, rather than waiting for the next clock tick. You can also use distributed ram to create small ROMs. However, distributed ram is not suited to large memories, you&rsquo;ll get better performance (and lower power consumption) for memories larger than about 128 bits using BRAM (see next section).</p>
<p>Not all FPGAs support distributed ram, for example the iCE40 UP5K doesn&rsquo;t. In Xilinx 7 Series FPGAs, only LUTs in SLICEM blocks may be used as memory. A Spartan 7S25 FPGA has 14,600 6-input LUTs, of which 5,000 are SLICEM, so you have a maximum of: 5,000 x 64 bits = 320,000 bits.<br>
For more on Xilinx distributed ram see <a href="https://www.xilinx.com/support/documentation/user_guides/ug474_7Series_CLB.pdf">UG474: 7 Series FPGAs Configurable Logic Block</a>.</p>
<p>The following example shows a ROM module using distributed ram (note the lack of a clock):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> rom_async #(
    <span style="color:#66d9ef">parameter</span> WIDTH<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>, 
    <span style="color:#66d9ef">parameter</span> DEPTH<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>, 
    <span style="color:#66d9ef">parameter</span> INIT_F<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>,
    <span style="color:#66d9ef">localparam</span> ADDRW<span style="color:#f92672">=</span>$clog2(DEPTH)
    ) (
    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr,
    <span style="color:#66d9ef">output</span>     <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] data
    );

    <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] memory [DEPTH];

    <span style="color:#66d9ef">initial</span> <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (INIT_F <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">begin</span>
            $display(<span style="color:#e6db74">&#34;Creating rom_async from init file &#39;%s&#39;.&#34;</span>, INIT_F);
            $readmemh(INIT_F, memory);
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">always_comb</span> data <span style="color:#f92672">=</span> memory[addr];
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><p>To learn more about loading memory with <code>$readmemh</code> see <a href="/posts/initialize-memory-in-verilog/">Initialize Memory in Verilog</a>.</p>
<h2 id="block-ram">Block RAM</h2>
<p>Block ram (BRAM) is implemented using dedicated ram circuitry within the FPGA. BRAM is broken down into many small blocks, 4 Kb for iCE40 UP5K and 18/36 Kb for Spartan 7S25. Block ram is ideal for memories from a few hundred bits, up to hundreds of kilobits. But BRAM is not just more efficient than distributed ram for larger memories, it supports two independent clocks, making it ideal to cross clock domains and build FIFOs.</p>
<p>Block ram is one of the great things about developing hardware with FPGAs.</p>
<p>Block ram data widths&hellip;</p>
<p>Block ram columns&hellip;</p>
<p>Buffers and caches&hellip;</p>
<p>FIFOs&hellip;</p>
<p><em>Being written&hellip;</em></p>
<p>The following example shows a Lattice iCE40 block ram module. For more details on Lattice BRAM see <a href="http://www.latticesemi.com/dynamic/view_document.cfm?document_id=47775">Memory Usage Guide for iCE40 Devices</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> bram_ice40 #(
    <span style="color:#66d9ef">parameter</span> WIDTH<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>, 
    <span style="color:#66d9ef">parameter</span> DEPTH<span style="color:#f92672">=</span><span style="color:#ae81ff">512</span>, 
    <span style="color:#66d9ef">parameter</span> INIT_F<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>,
    <span style="color:#66d9ef">localparam</span> ADDRW<span style="color:#f92672">=</span>$clog2(DEPTH)
    ) (
    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> clk,
    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr,
    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> we,
    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] data_in,
    <span style="color:#66d9ef">output</span>     <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] data_out
    );

    <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] memory [DEPTH];

    <span style="color:#66d9ef">initial</span> <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (INIT_F <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">begin</span>
            $display(<span style="color:#e6db74">&#34;Creating bram from init file &#39;%s&#39;.&#34;</span>, INIT_F);
            $readmemb(INIT_F, memory);  <span style="color:#75715e">// binary file
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (we) memory[addr] <span style="color:#f92672">&lt;=</span> data_in;
        data_out <span style="color:#f92672">=</span> memory[addr];
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><p>The following example shows a basic Xilinx block ram module using a single read and a single write port. For more details on Xilinx BRAM see <a href="https://www.xilinx.com/support/documentation/user_guides/ug473_7Series_Memory_Resources.pdf">UG473: 7 Series FPGAs Memory Resources</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> bram_basic_xc7 #(
    <span style="color:#66d9ef">parameter</span> WIDTH<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>, 
    <span style="color:#66d9ef">parameter</span> DEPTH<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>, 
    <span style="color:#66d9ef">parameter</span> INIT_F<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>,
    <span style="color:#66d9ef">localparam</span> ADDRW<span style="color:#f92672">=</span>$clog2(DEPTH)
    ) (
    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> clk,                       <span style="color:#75715e">// clock (port a &amp; b)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> we,                        <span style="color:#75715e">// write enable (port a)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_write,    <span style="color:#75715e">// write address (port a)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_read,     <span style="color:#75715e">// read address (port b)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span> <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] data_in,       <span style="color:#75715e">// data in (port a)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>     <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] data_out       <span style="color:#75715e">// data out (port b)
</span><span style="color:#75715e"></span>    );

    <span style="color:#75715e">/* verilator lint_off MULTIDRIVEN */</span>
    <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] memory [DEPTH];
    <span style="color:#75715e">/* verilator lint_on MULTIDRIVEN */</span>

    <span style="color:#66d9ef">initial</span> <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (INIT_F <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">begin</span>
            $display(<span style="color:#e6db74">&#34;Loading memory init file &#39;%s&#39; into bram_basic.&#34;</span>, INIT_F);
            $readmemh(INIT_F, memory);
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// Port A: Sync Write
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (we) <span style="color:#66d9ef">begin</span>
            memory[addr_write] <span style="color:#f92672">&lt;=</span> data_in;
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// Port B: Sync Read
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
        data_out <span style="color:#f92672">&lt;=</span> memory[addr_read];
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><h3 id="ultraram">UltraRAM</h3>
<p>UltraRAM is a type of memory available in Xilinx UltraScale and UltraScale+ FPGAs. UltraRAM is like block ram on steroids: bigger but less agile. The blocks are 288 Kb in size and combining all the blocks in a column gives you up to 36 Mb of memory to play with. However, UltraRAM does not support independent clocks on its two ports and is a fixed 72 bits wide.</p>
<h2 id="static-ram">Static RAM</h2>
<p>If you were to imagine a memory chip, you&rsquo;d probably imagine something like static ram (SRAM). You provide the address of a the element you want on the address bus, wait some nanoseconds and the data is returned on the data bus.</p>
<p>SRAM&rsquo;s big issue is cost. Fast SRAM is really expensive&hellip;</p>
<p>Static RAM is available in both synchronous and asynchronous types&hellip;</p>
<p><em>Being written&hellip;</em></p>
<h2 id="dynamic-ram">Dynamic RAM</h2>
<p>This is the everyday memory that forms the main memory in your PC. It&rsquo;s cheap and offers plenty of bandwidth, but DRAM is complex to interface with: you&rsquo;re almost certainly going to want to use vendor IP blocks and a cache to make DRAM usable. If you&rsquo;re streaming data, or interfacing with a CPU, then DRAM works well, but for random I/O the high latency is a significant issue.</p>
<p><em>Being written&hellip;</em></p>
<h2 id="serial-ram">Serial RAM</h2>
<p>xSPI Memory &amp; HyperRAM</p>
<p>These serial ram technologies are fundamentally DRAM, but have self refresh technology and a simplified serial interface that makes them simpler to implement on PCBs, and simpler to drive with FPGA logic.</p>
<p><em>Being written&hellip;</em></p>
<h2 id="high-bandwidth-memory">High Bandwidth Memory</h2>
<p>AKA HBM - Bandwidth, bandwidth and more bandwidth&hellip;</p>
<p><em>Being written&hellip;</em></p>
<p><em>PS. The wonderful image of the Micron MT4C1024 DRAM used in the social media card for this post comes from <a href="https://zeptobars.com/en/read/Micron-MT4C1024-dram">Zeptobars</a> and is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons licence</a>.</em></p>

      
      <div class="related">

<h3>Similar articles:</h3>
<ul>
	
	<li><a href="/posts/initialize-memory-in-verilog/">Initialize Memory in Verilog</a></li>
	
	<li><a href="/posts/division-in-verilog/">Division in Verilog</a></li>
	
	<li><a href="/posts/video-timings-vga-720p-1080p/">Video Timings: VGA, SVGA, 720p, 1080p</a></li>
	
	<li><a href="/posts/fixed-point-numbers-in-verilog/">Fixed Point Numbers in Verilog</a></li>
	
</ul>
</div>
      
    </div>
    
  </div>
</section>

    <script src="/js/copycode.js"></script>



<section class="section">
  <div class="container has-text-centered">
    <p>©2020 Will Green, Project F</p>
    
  </div>
</section>


<script src="https://narwhal.projectf.io/script.js" site="EVCGKVDN" defer></script>
</body>
</html>

